/*
    Code Dual Core 2 CPU 2 CLA viet boi LUU TA TRUONG LINH K65
 */

// Included Files
#include "cla_sdfm_filter_sync_shared.h"
#include "F2837xD_cla.h"
#include "F2837xD_piectrl.h"
#include "F2837xD_gpio.h"
#include "F2837xD_epwm.h"
#include "F2837xD_EPwm_defines.h"
#include "RAMP_GEN_CLA.h"
#include "Ramp.h"
#include "iPARK_CLA.h"
#include "UabtoUabc.h"
#include "SVM3D_DQZ_CLA_TOI_UU.h"
#include "SVM_DQ_CLA.h"
#include "PWM_3T_CLA.h"
#include "PARK_CLA.h"
#include "CLAmath.h"
#include "PV_Variables.h"
#include "F2837xD_adc.h"
#include "PV_Setting.h"
#include "LowFilter.h"
#include "CLARKE_3PHASE_CLA.h"
#include "PI_NORMAL_CLA.h"
#include "SinPWM_IFB_CLA.h"
#include "PWM_3T_IFB_CLA.h"
#include "PARK_1PHASE_CLA_PE.h"
#include "PLL_1PHASE_CLA_PE.h"
#include "PR_new.h"
//#include "Kalman.h"
#include "PLL_PHASE_CLA_PE.h"

// Defines CLA_DEBUG
#define CLA_DEBUG       0

#pragma DATA_SECTION(Cla1Task1, "Cla1Prog");

#pragma DATA_SECTION(IsrTicker,"CLADataLS0");
volatile Uint32 IsrTicker;

#if(SET_MODE_RUN == THREE_PHASE_MODE)

#pragma DATA_SECTION(rg_har_1st,"CLADataLS0");
volatile RAMP_GEN_CLA rg_har_1st;

#pragma DATA_SECTION(rc_Ref,"CLADataLS0");
volatile RC_CLA rc_Ref;

#pragma DATA_SECTION(ipark_voltref,"CLADataLS0");
volatile iPARK_CLA ipark_voltref;

#pragma DATA_SECTION(UabtoUabc,"CLADataLS0");
volatile UABtoUabc_CLA UabtoUabc;

#pragma DATA_SECTION(Svm3d,"CLADataLS0");
volatile SVM3D_DQZ_GEN_CLA_1 Svm3d;

#pragma DATA_SECTION(Svm2d,"CLADataLS0");
volatile SVGENDQ_CLA Svm2d;

#pragma DATA_SECTION(pwm,"CLADataLS0");
volatile PWMGEN_3T_CLA pwm;

#pragma DATA_SECTION(park_curr,"CLADataLS0");
volatile PARK_CLA park_curr;

#pragma DATA_SECTION(park_volt,"CLADataLS0");
volatile PARK_CLA park_volt;

#pragma DATA_SECTION(park_volt_pll,"CLADataLS0");
volatile PARK_CLA park_volt_pll;

#pragma DATA_SECTION(CpuToCLA,"CpuToCla1MsgRAM");
volatile CPU_TO_CLA CpuToCLA;

#pragma DATA_SECTION(ClaToCPU,"Cla1ToCpuMsgRAM");
volatile  CLA_TO_CPU ClaToCPU;

#pragma DATA_SECTION(START_CONTROLLER,"CLADataLS0");
volatile short START_CONTROLLER;

#pragma DATA_SECTION(START_ADC,"CLADataLS0");
volatile short START_ADC;

#pragma DATA_SECTION(AdcValue,"CLADataLS0");
volatile ADC_VALUE AdcValue;

#pragma DATA_SECTION(adc_filter,"CLADataLS0");
volatile ADC_VALUE adc_filter;

#pragma DATA_SECTION(adc_filter_kalman,"CLADataLS0");
volatile ADC_VALUE adc_filter_kalman;

/* Low pass filter  */
#pragma DATA_SECTION(filter_Udc,"CLADataLS0");
volatile LOWPASSFILTER  filter_Udc;
//
#pragma DATA_SECTION(filter_VaG,"CLADataLS0");
volatile LOWPASSFILTER  filter_VaG;
//
#pragma DATA_SECTION(filter_VbG,"CLADataLS0");
volatile LOWPASSFILTER  filter_VbG;
//
#pragma DATA_SECTION(filter_VcG,"CLADataLS0");
volatile LOWPASSFILTER  filter_VcG;

#pragma DATA_SECTION(filter_Usd,"CLADataLS0");
volatile LOWPASSFILTER  filter_Usd;

#pragma DATA_SECTION(filter_Usq,"CLADataLS0");
volatile LOWPASSFILTER  filter_Usq;

#pragma DATA_SECTION(clarke_volt,"CLADataLS0");
volatile CLARKE_3PHASE_CLA clarke_volt;

#pragma DATA_SECTION(clarke_curr,"CLADataLS0");
volatile CLARKE_3PHASE_CLA clarke_curr;

#pragma DATA_SECTION(clarke_volt_pll,"CLADataLS0");
volatile CLARKE_3PHASE_CLA clarke_volt_pll;

#pragma DATA_SECTION(pll_3phase,"CLADataLS0");
volatile PLL_PHASE_CLA pll_3phase;

#pragma DATA_SECTION(pi_curr_id,"CLADataLS0");
volatile PI_NORMAL_CLA pi_curr_id;

#pragma DATA_SECTION(pi_curr_iq,"CLADataLS0");
volatile PI_NORMAL_CLA pi_curr_iq;

#pragma DATA_SECTION(pi_curr_iz,"CLADataLS0");
volatile PI_NORMAL_CLA pi_curr_iz;

#pragma DATA_SECTION(controller_error_curr_isd,"CLADataLS0");
volatile short controller_error_curr_isd;

#pragma DATA_SECTION(controller_error_curr_isq,"CLADataLS0");
volatile short controller_error_curr_isq;

#pragma DATA_SECTION(loop_volt_Udc,"CLADataLS0");
volatile short loop_volt_Udc;

#pragma DATA_SECTION(pi_volt_Usd,"CLADataLS0");
volatile PI_NORMAL_CLA pi_volt_Usd;

#pragma DATA_SECTION(pi_volt_Usq,"CLADataLS0");
volatile PI_NORMAL_CLA pi_volt_Usq;

#pragma DATA_SECTION(loop_volt_Us,"CLADataLS0");
volatile int loop_volt_Us;

#pragma DATA_SECTION(data1,"CLADataLS0");
volatile DATA data1;

//#pragma DATA_SECTION(kf,"CLADataLS0");
//volatile KalmanFilter kf_VaG;
//
//#pragma DATA_SECTION(kf,"CLADataLS0");
//volatile KalmanFilter kf_VbG;
//
//#pragma DATA_SECTION(kf,"CLADataLS0");
//volatile KalmanFilter kf_VcG;

#endif

#if(SET_MODE_RUN == SINGLE_PHASE_MODE)

#pragma DATA_SECTION(CpuToCLA,"CpuToCla1MsgRAM");
volatile CPU_TO_CLA CpuToCLA;

#pragma DATA_SECTION(START_CONTROLLER,"CLADataLS0");
volatile short START_CONTROLLER;

#pragma DATA_SECTION(rc1,"CLADataLS0");
volatile RC_CLA rc1;

#pragma DATA_SECTION(rg1,"CLADataLS0");
volatile RAMP_GEN_CLA rg1;

#pragma DATA_SECTION(rc_Ref,"CLADataLS0");
volatile RC_CLA rc_Ref;

#pragma DATA_SECTION(Us,"CLADataLS0");
volatile float Us;

#pragma DATA_SECTION(Spwm,"CLADataLS0");
volatile SPWM_CLA Spwm;

#pragma DATA_SECTION(pwm,"CLADataLS0");
volatile PWMGEN_3T_IFB_CLA pwm;

#pragma DATA_SECTION(ClaToCPU,"Cla1ToCpuMsgRAM");
volatile  CLA_TO_CPU ClaToCPU;

#pragma DATA_SECTION(park_volt_Vg,"CLADataLS0");
volatile PARK_1PHASE_CLA park_volt_Vg;

#pragma DATA_SECTION(pll_Vg,"CLADataLS0");
volatile PLL_1PHASE_CLA pll_Vg;

#pragma DATA_SECTION(START_ADC,"CLADataLS0");
volatile short START_ADC;

#pragma DATA_SECTION(AdcValue,"CLADataLS0");
volatile ADC_VALUE AdcValue;

#pragma DATA_SECTION(data1,"CLADataLS0");
volatile DATA data1;

#pragma DATA_SECTION(PR_Calculator_curr_H1,"CLADataLS0");
volatile PR_Calculator_new PR_Calculator_curr_H1;

#pragma DATA_SECTION(PR_Calculator_curr_H2,"CLADataLS0");
volatile PR_Calculator_new PR_Calculator_curr_H2;

#pragma DATA_SECTION(PR_Calculator_curr_extra,"CLADataLS0");
volatile PR_Calculator_new PR_Calculator_curr_extra;

#pragma DATA_SECTION(PR_Parameter_curr_H1,"CLADataLS0");
volatile PR_Parameter_new PR_Parameter_curr_H1;

#pragma DATA_SECTION(PR_Parameter_curr_extra,"CLADataLS0");
volatile PR_Parameter_new PR_Parameter_curr_extra;

#pragma DATA_SECTION(PR_Parameter_curr_H2,"CLADataLS0");
volatile PR_Parameter_new PR_Parameter_curr_H2;

#pragma DATA_SECTION(filter_Udc,"CLADataLS0");
volatile LOWPASSFILTER  filter_Udc;
//
#pragma DATA_SECTION(filter_VaG,"CLADataLS0");
volatile LOWPASSFILTER  filter_VaG;
//
#pragma DATA_SECTION(filter_VbG,"CLADataLS0");
volatile LOWPASSFILTER  filter_VbG;
//
#pragma DATA_SECTION(filter_VcG,"CLADataLS0");
volatile LOWPASSFILTER  filter_VcG;

#pragma DATA_SECTION(adc_filter,"CLADataLS0");
volatile ADC_VALUE adc_filter;

#pragma DATA_SECTION(PR_Calculator_curr_extra,"CLADataLS0");
volatile PR_Calculator_new PR_Calculator_voltage;

#pragma DATA_SECTION(PR_Parameter_curr_H2,"CLADataLS0");
volatile PR_Parameter_new PR_Parameter_voltage;

#endif

Uint16 TaskCpu1Cla1;
Uint16 TaskCpu1Cla1_task2;
// Task 1
//
__interrupt void Cla1Task1 ( void )
{
    #if (CLA_DEBUG==1)
    __mdebugstop();
    #endif

    TaskCpu1Cla1++;

#if(SET_MODE_RUN == THREE_PHASE_MODE)

    if(CpuToCLA.EnableADC == 1 && START_ADC == 2)
    {
        START_ADC = 1;
    }
    if(START_ADC == 1)
    {

        #if(TUNNING_ADC == 1)
            // VaG
            if(CpuToCLA.ADCoffset_VaG > 2048.0)
            {
                AdcValue.Va_G = CpuToCLA.ADCgain_VaG*(VaG_HCPL - CpuToCLA.ADCoffset_VaG)/(4096.0 - CpuToCLA.ADCoffset_VaG);
            }
            else
            {
                AdcValue.Va_G = CpuToCLA.ADCgain_VaG*(VaG_HCPL - CpuToCLA.ADCoffset_VaG)/(CpuToCLA.ADCoffset_VaG);
            }
            // VbG
            if(CpuToCLA.ADCoffset_VbG > 2048.0)
            {
                AdcValue.Vb_G = CpuToCLA.ADCgain_VbG*(VbG_HCPL - CpuToCLA.ADCoffset_VbG)/(4096.0 - CpuToCLA.ADCoffset_VbG);
            }
            else
            {
                AdcValue.Vb_G = CpuToCLA.ADCgain_VbG*(VbG_HCPL - CpuToCLA.ADCoffset_VbG)/(CpuToCLA.ADCoffset_VbG);
            }
            // VcG
            if(CpuToCLA.ADCoffset_VcG > 2048.0)
            {
                AdcValue.Vc_G = CpuToCLA.ADCgain_VcG*(VcG_HCPL - CpuToCLA.ADCoffset_VcG)/(4096.0 - CpuToCLA.ADCoffset_VcG);
            }
            else
            {
                AdcValue.Vc_G = CpuToCLA.ADCgain_VcG*(VcG_HCPL - CpuToCLA.ADCoffset_VcG)/(CpuToCLA.ADCoffset_VcG);
            }
            // data_Vg
            data1.Vg_max_data_cal =  (data1.Vg_rms/400.0) * can2 * 10000 + 10000;
            data1.Vg_min_data_cal = 10000 - (data1.Vg_rms/400.0) * can2 * 10000;
            data1.Vg_max_sub_min_cal = data1.Vg_max_data_cal - data1.Vg_min_data_cal;

            data1.Vg_max_sub_min_real = data1.Vg_max_data_real - data1.Vg_min_data_real;

            // Ia_inv
            if(CpuToCLA.ADCoffset_Ia_inv > 2048.0)
            {
                AdcValue.Ia_inv = CpuToCLA.ADCgain_Ia_inv*(IA_INV_LEM - CpuToCLA.ADCoffset_Ia_inv)/(4096.0 - CpuToCLA.ADCoffset_Ia_inv);
            }
            else
            {
                AdcValue.Ia_inv = CpuToCLA.ADCgain_Ia_inv*(IA_INV_LEM - CpuToCLA.ADCoffset_Ia_inv)/(CpuToCLA.ADCoffset_Ia_inv);
            }
            // Ib_inv
            if(CpuToCLA.ADCoffset_Ib_inv > 2048.0)
            {
                AdcValue.Ib_inv = CpuToCLA.ADCgain_Ib_inv*(IB_INV_LEM  - CpuToCLA.ADCoffset_Ib_inv)/(4096.0 - CpuToCLA.ADCoffset_Ib_inv);
            }
            else
            {
                AdcValue.Ib_inv = CpuToCLA.ADCgain_Ib_inv*(IB_INV_LEM  - CpuToCLA.ADCoffset_Ib_inv)/(CpuToCLA.ADCoffset_Ib_inv);
            }
            // Ic_inv
            if(CpuToCLA.ADCoffset_Ic_inv > 2048.0)
            {
                AdcValue.Ic_inv = CpuToCLA.ADCgain_Ic_inv*(IC_INV_LEM - CpuToCLA.ADCoffset_Ic_inv)/(4096.0 - CpuToCLA.ADCoffset_Ic_inv);
            }
            else
            {
                AdcValue.Ic_inv = CpuToCLA.ADCgain_Ic_inv*(IC_INV_LEM - CpuToCLA.ADCoffset_Ic_inv)/(CpuToCLA.ADCoffset_Ic_inv);
            }
            // data_Ig
            data1.Ig_max_data_cal =  (data1.Ig_rms/10.0) * can2 * 10000 + 10000;
            data1.Ig_min_data_cal = 10000 - (data1.Ig_rms/10.0) * can2 * 10000;
            data1.Ig_max_sub_min_cal = data1.Ig_max_data_cal - data1.Ig_min_data_cal;

            data1.Ig_max_sub_min_real = data1.Ig_max_data_real - data1.Ig_min_data_real;
            // Udc
            if(UDC_HCPL > CpuToCLA.ADCoffset_Udc)
            {
                AdcValue.Udc = CpuToCLA.ADCgain_Udc*(UDC_HCPL - CpuToCLA.ADCoffset_Udc)/(4096.0 - CpuToCLA.ADCoffset_Udc);
            }
            else AdcValue.Udc = 0.0;

        #endif

        #if(TUNNING_ADC == 2)

            AdcValue.Va_G = 0.775*(VaG_HCPL - 2703)/(4096.0 - 2703);
            AdcValue.Vb_G = 0.745*(VbG_HCPL - 2604)/(4096.0 - 2604);
            AdcValue.Vc_G = 0.765*(VcG_HCPL - 2694)/(4096.0 - 2694);
            AdcValue.Ia_inv = 1.52*(IA_INV_LEM - 2061)/(4096.0 - 2061);
            AdcValue.Ib_inv = 1.52*(IB_INV_LEM  - 2050)/(4096.0 - 2050);
            AdcValue.Ic_inv = 1.475*(IC_INV_LEM - 2035)/(4096.0 - 2035);
            if (UDC_HCPL > 4)
            {
                AdcValue.Udc = 1.0*(UDC_HCPL - 4)/(4096.0 - 4);
            }
            else AdcValue.Udc = 0.0;

        #endif

//        KALMAN_UPDATE(kf_VaG, AdcValue.Va_G);  // Cập nhật Kalman với giá trị thực tế
//        KALMAN_UPDATE(kf_VbG, AdcValue.Vb_G);  // Cập nhật Kalman với giá trị thực tế
//        KALMAN_UPDATE(kf_VcG, AdcValue.Vc_G);  // Cập nhật Kalman với giá trị thực tế

        //KALMAN_UPDATE_V2(kf_VaG, AdcValue.Va_G);

        filter_Udc.Vin = AdcValue.Udc;
        LOWPASSFILTER_MACRO(filter_Udc)
        adc_filter.Udc = filter_Udc.Vout;

        filter_VaG.Vin = AdcValue.Va_G;
        LOWPASSFILTER_MACRO(filter_VaG);
        adc_filter.Va_G = filter_VaG.Vout;

        filter_VbG.Vin = AdcValue.Vb_G;
        LOWPASSFILTER_MACRO(filter_VbG);
        adc_filter.Vb_G = filter_VbG.Vout;

        filter_VcG.Vin = AdcValue.Vc_G;
        LOWPASSFILTER_MACRO(filter_VcG);
        adc_filter.Vc_G = filter_VcG.Vout;

        #if(SET_MODE_READ == READ_VOLTAGE_AC_AFTER_LPF)
            ClaToCPU.ADC_CPU.datalog1  = adc_filter.Va_G;
            ClaToCPU.ADC_CPU.datalog2  = adc_filter.Vb_G;
            ClaToCPU.ADC_CPU.datalog3  = adc_filter.Vc_G;
        #endif

        #if(SET_MODE_READ == READ_VOLTAGE_AC_BEFORE_LPF)
            ClaToCPU.ADC_CPU.datalog1  = AdcValue.Va_G;
            ClaToCPU.ADC_CPU.datalog2  = AdcValue.Vb_G;
            ClaToCPU.ADC_CPU.datalog3  = AdcValue.Vc_G;
        #endif

        #if(SET_MODE_READ == READ_VOLTAGE_DC)
            ClaToCPU.ADC_CPU.datalog1  = adc_filter.Udc;
            ClaToCPU.ADC_CPU.datalog2  = adc_filter.Vb_G;
            ClaToCPU.ADC_CPU.datalog3  = adc_filter.Vc_G;
        #endif

        #if(SET_MODE_READ == READ_CURRENT)
            ClaToCPU.ADC_CPU.datalog1  = AdcValue.Ia_inv;
            ClaToCPU.ADC_CPU.datalog2  = AdcValue.Ib_inv;
            ClaToCPU.ADC_CPU.datalog3  = AdcValue.Ic_inv;
        #endif

        #if(SET_MODE_READ == READ_VOLTAGE_AC_AFTER_KALMAN)
            ClaToCPU.ADC_CPU.datalog1  = kf_VaG.x;
            ClaToCPU.ADC_CPU.datalog2  = kf_VbG.x;
            ClaToCPU.ADC_CPU.datalog3  = kf_VcG.x;
        #endif

        #if(SET_MODE_READ == READ_OUTPUT_CURRENT_CONTROLLER)
            ClaToCPU.ADC_CPU.datalog1  = pi_curr_id.OUT;
            ClaToCPU.ADC_CPU.datalog2  = pi_curr_iq.OUT;
            ClaToCPU.ADC_CPU.datalog3  = pi_curr_iz.OUT;
        #endif

        #if(SET_MODE_READ == READ_VOLTAGE_AC_TEST_VB)
            ClaToCPU.ADC_CPU.datalog1  = adc_filter.Va_G + adc_filter.Vc_G;
            ClaToCPU.ADC_CPU.datalog2  = adc_filter.Vb_G;
            ClaToCPU.ADC_CPU.datalog3  = 1 - adc_filter.Va_G - adc_filter.Vc_G;
        #endif

        #if(BUILDLEVEL == LEVEL4)
            // Kiểm tra xem Udc có đủ để điều chế ra điện áp Vac đặt hay không
            if(adc_filter.Udc < (CpuToCLA.VdTesting/400/220/800) * 650 * 400)
            {
                ClaToCPU.Udc_under_modulation = 1;
            }
            else
            {
                ClaToCPU.Udc_under_modulation = 0;
            }
        #endif

//        // Calculator PLL three phase
//        clarke_volt_pll.As  = adc_filter.Va_G;
//        clarke_volt_pll.Bs  = adc_filter.Vb_G;
//        clarke_volt_pll.Cs  = adc_filter.Vc_G;
//
//        CLARKE_3PHASE_CLA_V2_MARCO(clarke_volt_pll)
//
//        park_volt_pll.alpha = clarke_volt_pll.Alpha;
//        park_volt_pll.beta = clarke_volt_pll.Beta;
//        park_volt_pll.theta = pll_3phase.Theta_har_1st;
//        park_volt_pll.sine = CLAsinPU(pll_3phase.Theta_har_1st);
//        park_volt_pll.cos = CLAcosPU(pll_3phase.Theta_har_1st);
//        PARK_CLA_V2_MACRO(park_volt_pll)
//
//        filter_Usd.Vin = park_volt_pll.d;
//        LOWPASSFILTER_MACRO(filter_Usd)
//
//        filter_Usq.Vin = park_volt_pll.q;
//        LOWPASSFILTER_MACRO(filter_Usq)
//
//        pll_3phase.Usq = filter_Usq.Vout;
//
//        PLL_PHASE_CLA_V3_MACRO(pll_3phase)

        #if (BUILDLEVEL == LEVEL1 || BUILDLEVEL == LEVEL3 || BUILDLEVEL == LEVEL4)
            if(CpuToCLA.EnableFlag == 1)
            {
                START_CONTROLLER = 1;
            }
            else START_CONTROLLER = 0;
        #endif
    }
    if(START_CONTROLLER == 1)
    {
        EPwm4Regs.DBCTL.bit.OUT_MODE = 3; // Dead-band áp dụng cho cả hai tín hiệu PWM A và B.
        EPwm6Regs.DBCTL.bit.OUT_MODE = 3;
        EPwm5Regs.DBCTL.bit.OUT_MODE = 3;
        EPwm8Regs.DBCTL.bit.OUT_MODE = 3;

        #if(BUILDLEVEL == LEVEL1)

            IsrTicker++;
            rg_har_1st.Freq = 50.0/150.0;
            RAMP_GEN_CLA_MACRO(rg_har_1st)

            rc_Ref.TargetValue = 230.0/400.0;
            //rc_Ref.TargetValue = CpuToCLA.VdTesting/400.0;
            RC_CLA_MACRO(rc_Ref)

            ipark_voltref.d    = can2*rc_Ref.SetpointValue;
            ipark_voltref.q    = 0;
            ipark_voltref.z    = 0;
            ipark_voltref.sine = CLAsinPU(rg_har_1st.Out);
            ipark_voltref.cos  = CLAcosPU(rg_har_1st.Out);
            iPARK_CLA_V3_MACRO(ipark_voltref)

    #if(MODE_MODULATION == MODE_MODULATION_SVM2D)

            Svm2d.Ualpha = ipark_voltref.alpha;
            Svm2d.Ubeta = ipark_voltref.beta;
            Svm2d.Udc = 650.0/800.0;
            SVGEN_CLA_MACRO(Svm2d)

            pwm.MfuncA1 = Svm2d.da;
            pwm.MfuncA2 = Svm2d.db;
            pwm.MfuncB1 = Svm2d.dc;
            pwm.MfuncB2 = Svm2d.dn;

    #endif

    #if(MODE_MODULATION == MODE_MODULATION_SVM3D)

            Svm3d.Ualpha = ipark_voltref.alpha;
            Svm3d.Ubeta  = ipark_voltref.beta;
            Svm3d.Ugamma = ipark_voltref.gamma;

            Svm3d.Udc = 650.0/800.0;
            SVM3D_DQZ_GEN_CLA_MACRO_1(Svm3d)

            pwm.MfuncA1 = Svm3d.da;
            pwm.MfuncA2 = Svm3d.db;
            pwm.MfuncB1 = Svm3d.dc;
            pwm.MfuncB2 = Svm3d.dn;

    #endif

            EPwm4Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncA1*pwm.PeriodMax);
            EPwm6Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncA2*pwm.PeriodMax);                                                                                         \
            EPwm5Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncB1*pwm.PeriodMax);
            EPwm8Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncB2*pwm.PeriodMax);

        #endif

        #if(BUILDLEVEL == LEVEL3)

            IsrTicker++;

            rg_har_1st.Freq = 50.0/150.0;
            RAMP_GEN_CLA_MACRO(rg_har_1st) // Tao theta

            rc_Ref.TargetValue = CpuToCLA.IdTesting/10.0; // Id*
            RC_CLA_MACRO(rc_Ref) // Ramp luong dat Id

            clarke_curr.As  = AdcValue.Ia_inv;  // Phase A curr
            clarke_curr.Bs  = AdcValue.Ib_inv;  // Phase B curr
            clarke_curr.Cs  = AdcValue.Ic_inv;  // Phase C curr
            CLARKE_3PHASE_CLA_V3_MARCO(clarke_curr) // Chuyen abc sang anpha-beta-gamma

            park_curr.theta = rg_har_1st.Out; // Dau ra cua rg_har_1st chinh la theta
            park_curr.alpha = clarke_curr.Alpha;
            park_curr.beta = clarke_curr.Beta;
            park_curr.gamma = clarke_curr.Gamma;
            park_curr.sine  = CLAsinPU(rg_har_1st.Out); // sin(theta)
            park_curr.cos  = CLAcosPU(rg_har_1st.Out); // cos(theta)
            PARK_CLA_V3_MACRO(park_curr) // Chuyen anpha-beta-gamma sang dqz

            // Current controller
            pi_curr_id.REF      = can2*rc_Ref.SetpointValue; // SetpointValue la gia tri dat sau ramp
            pi_curr_id.INPUT    = park_curr.d;  // Id dau vao la gia tri d sau khoi park
            pi_curr_id.ERROR    = pi_curr_id.REF - pi_curr_id.INPUT; // Do sai lech
            PI_NORMAL_MACRO(pi_curr_id);

            pi_curr_iq.REF      = 0;
            pi_curr_iq.INPUT    = park_curr.q; // Iq dau vao la gia tri q sau khoi park
            pi_curr_iq.ERROR    = pi_curr_iq.REF - pi_curr_iq.INPUT; // Do sai lech
            PI_NORMAL_MACRO(pi_curr_iq);

            pi_curr_iz.REF      = 0;
            pi_curr_iz.INPUT    = park_curr.z; // Iz dau vao la gia tri z sau khoi park
            pi_curr_iz.ERROR    = pi_curr_iz.REF - pi_curr_iz.INPUT; // Do sai lech
            PI_NORMAL_MACRO(pi_curr_iz);

            ipark_voltref.d = pi_curr_id.OUT;
            ipark_voltref.q = pi_curr_iq.OUT;
            ipark_voltref.z = pi_curr_iz.OUT;
            ipark_voltref.sine = CLAsinPU(rg_har_1st.Out); // sin(theta)
            ipark_voltref.cos  = CLAcosPU(rg_har_1st.Out); // cos(theta)
            iPARK_CLA_V3_MACRO(ipark_voltref) // Chuyen dqz sang anpha-beta-gamma

            Svm3d.Ualpha = ipark_voltref.alpha;
            Svm3d.Ubeta = ipark_voltref.beta;
            Svm3d.Ugamma = ipark_voltref.gamma;
            Svm3d.Udc = adc_filter.Udc;

            SVM3D_DQZ_GEN_CLA_MACRO_1(Svm3d)

            pwm.MfuncA1 = Svm3d.da;
            pwm.MfuncA2 = Svm3d.db;
            pwm.MfuncB1 = Svm3d.dc;
            pwm.MfuncB2 = Svm3d.dn;

            EPwm4Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncA1*pwm.PeriodMax);
            EPwm6Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncA2*pwm.PeriodMax);

            EPwm5Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncB1*pwm.PeriodMax);
            EPwm8Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncB2*pwm.PeriodMax);

            if(pi_curr_id.OUT > 0.99 || pi_curr_id.OUT < -0.99)controller_error_curr_isd++;
            else controller_error_curr_isd = 0;

            if(pi_curr_id.OUT > 0.99 || pi_curr_id.OUT < -0.99) controller_error_curr_isq++;
            else controller_error_curr_isq = 0;

        #endif
        #if(BUILDLEVEL == LEVEL4)

            IsrTicker++;

            rg_har_1st.Freq = 50.0/150.0;
            RAMP_GEN_CLA_MACRO(rg_har_1st) // Tao theta

            rc_Ref.TargetValue = can2*CpuToCLA.VdTesting/400.0; // Dat gia tri Ud*
            RC_CLA_MACRO(rc_Ref) // Ramp gia tri Ud*

            clarke_curr.As  = AdcValue.Ia_inv;  // Phase A curr
            clarke_curr.Bs  = AdcValue.Ib_inv;  // Phase B curr
            clarke_curr.Cs  = AdcValue.Ic_inv;  // Phase C curr
            CLARKE_3PHASE_CLA_V3_MARCO(clarke_curr)

            clarke_volt.As  = adc_filter.Va_G;  // Phase A volt
            clarke_volt.Bs  = adc_filter.Vb_G;  // Phase B volt
            clarke_volt.Cs  = adc_filter.Vc_G;  // Phase C volt
            CLARKE_3PHASE_CLA_V3_MARCO(clarke_volt)

            park_curr.theta = rg_har_1st.Out;
            park_curr.alpha = clarke_curr.Alpha;
            park_curr.beta  = clarke_curr.Beta;
            park_curr.gamma = clarke_curr.Gamma;
            park_curr.sine  = CLAsinPU(rg_har_1st.Out);
            park_curr.cos   = CLAcosPU(rg_har_1st.Out);

            PARK_CLA_V3_MACRO(park_curr)

            park_volt.theta = rg_har_1st.Out;
            park_volt.alpha = clarke_volt.Alpha;
            park_volt.beta  = clarke_volt.Beta;
            park_volt.gamma = clarke_volt.Gamma;
            park_volt.sine  = CLAsinPU(rg_har_1st.Out);
            park_volt.cos   = CLAcosPU(rg_har_1st.Out);
            PARK_CLA_V3_MACRO(park_volt)

            // Voltage controller
            if(loop_volt_Us >= 10)
            {
            pi_volt_Usd.REF      = rc_Ref.SetpointValue;
            pi_volt_Usd.INPUT    = park_volt.d;
            pi_volt_Usd.ERROR    = pi_volt_Usd.REF - pi_volt_Usd.INPUT;
            PI_NORMAL_MACRO(pi_volt_Usd)

            pi_volt_Usq.REF      = 0.0;
            pi_volt_Usq.INPUT    = park_volt.q;
            pi_volt_Usq.ERROR    = pi_volt_Usq.REF - pi_volt_Usq.INPUT;
            PI_NORMAL_MACRO(pi_volt_Usq)

            loop_volt_Us = 1;
            }
            else loop_volt_Us++;

            // Current controller
            pi_curr_id.REF      = pi_volt_Usd.OUT;
            pi_curr_id.INPUT    = park_curr.d;
            pi_curr_id.ERROR    =  pi_curr_id.REF - pi_curr_id.INPUT ;
            PI_NORMAL_MACRO(pi_curr_id);

            pi_curr_iq.REF      = pi_volt_Usq.OUT;
            pi_curr_iq.INPUT    = park_curr.q;
            pi_curr_iq.ERROR    =  pi_curr_iq.REF - pi_curr_iq.INPUT;
            PI_NORMAL_MACRO(pi_curr_iq);

            pi_curr_iz.REF      = 0.0;
            pi_curr_iz.INPUT    = park_curr.z;
            pi_curr_iz.ERROR    =  pi_curr_iz.REF - pi_curr_iz.INPUT ;
            PI_NORMAL_MACRO(pi_curr_iz);

            ipark_voltref.d = pi_curr_id.OUT;
            ipark_voltref.q = pi_curr_iq.OUT;
            ipark_voltref.z = pi_curr_iz.OUT;

            ipark_voltref.sine = CLAsinPU(rg_har_1st.Out);
            ipark_voltref.cos  = CLAcosPU(rg_har_1st.Out);
            iPARK_CLA_V3_MACRO(ipark_voltref)

    #if(MODE_MODULATION == MODE_MODULATION_SVM2D)

            Svm2d.Ualpha = ipark_voltref.alpha;
            Svm2d.Ubeta = ipark_voltref.beta;
            Svm2d.Udc = adc_filter.Udc;
            SVGEN_CLA_MACRO(Svm2d)

            pwm.MfuncA1 = Svm2d.da;
            pwm.MfuncA2 = Svm2d.db;
            pwm.MfuncB1 = Svm2d.dc;
            pwm.MfuncB2 = Svm2d.dn;

    #endif

    #if(MODE_MODULATION == MODE_MODULATION_SVM3D)

            Svm3d.Ualpha = ipark_voltref.alpha;
            Svm3d.Ubeta  = ipark_voltref.beta;
            Svm3d.Ugamma = ipark_voltref.gamma;
            Svm3d.Udc = adc_filter.Udc;
            SVM3D_DQZ_GEN_CLA_MACRO_1(Svm3d)

            pwm.MfuncA1 = Svm3d.da;
            pwm.MfuncA2 = Svm3d.db;
            pwm.MfuncB1 = Svm3d.dc;
            pwm.MfuncB2 = Svm3d.dn;

    #endif

            EPwm4Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncA1*pwm.PeriodMax);
            EPwm6Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncA2*pwm.PeriodMax);
            EPwm5Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncB1*pwm.PeriodMax);
            EPwm8Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncB2*pwm.PeriodMax);
        #endif

        #if (BUILDLEVEL == LEVEL7)
            IsrTicker++;

            rc_Ref.TargetValue = can2*2.0/10.0;
            RC_CLA_MACRO(rc_Ref)

            clarke_curr.As  = AdcValue.Ia_inv;  // Phase A curr.
            clarke_curr.Bs  = AdcValue.Ib_inv;  // Phase B curr.
            clarke_curr.Cs  = AdcValue.Ic_inv;  // Phase C curr

            CLARKE_3PHASE_CLA_V3_MARCO(clarke_curr)

            park_curr.theta = pll_3phase.Theta_har_1st;
            park_curr.alpha = clarke_curr.Alpha;
            park_curr.beta = clarke_curr.Beta;
            park_curr.gamma = clarke_curr.Gamma;
            park_curr.sine  = CLAsinPU(pll_3phase.Theta_har_1st);
            park_curr.cos  = CLAcosPU(pll_3phase.Theta_har_1st);
            PARK_CLA_V3_MACRO(park_curr)

            //==============================================================================
            //  Current controller
            // ------------------------------------------------------------------------------
            pi_curr_id.REF      = rc_Ref.SetpointValue;
            pi_curr_id.INPUT    = park_curr.d;
            pi_curr_id.ERROR    = pi_curr_id.REF - pi_curr_id.INPUT;
            PI_NORMAL_MACRO(pi_curr_id);

            pi_curr_iq.REF      = 0;
            pi_curr_iq.INPUT    = park_curr.q;
            pi_curr_iq.ERROR    = pi_curr_iq.REF - pi_curr_iq.INPUT;
            PI_NORMAL_MACRO(pi_curr_iq);

            pi_curr_iz.REF      = 0;
            pi_curr_iz.INPUT    = park_curr.z;
            pi_curr_iz.ERROR    = pi_curr_iz.REF - pi_curr_iz.INPUT;
            PI_NORMAL_MACRO(pi_curr_iz);

            ipark_voltref.d = pi_curr_id.OUT  + filter_Usd.Vout;
            ipark_voltref.q = pi_curr_iq.OUT  + filter_Usq.Vout;
            ipark_voltref.z = pi_curr_iz.OUT;

            //          ipark_voltref.d = pi_curr_id.OUT  + filter_Usd.Vout + Wref*Li*park_curr.q*Is_max/Us_max;
            //          ipark_voltref.q = pi_curr_iq.OUT  + filter_Usq.Vout - Wref*Li*park_curr.d*Is_max/Us_max;
            //          ipark_voltref.z = pi_curr_iz.OUT;

            ipark_voltref.sine = CLAsinPU(pll_3phase.Theta_har_1st);
            ipark_voltref.cos  = CLAcosPU(pll_3phase.Theta_har_1st);
            iPARK_CLA_V3_MACRO(ipark_voltref)

            Svm3d.Ualpha = ipark_voltref.alpha;
            Svm3d.Ubeta = ipark_voltref.beta;
            Svm3d.Ugamma = ipark_voltref.gamma;
            Svm3d.Udc = adc_filter.Udc;
            SVM3D_DQZ_GEN_CLA_MACRO_1(Svm3d)

            pwm.MfuncA1 = Svm3d.da;
            pwm.MfuncA2 = Svm3d.db;
            pwm.MfuncB1 = Svm3d.dc;
            pwm.MfuncB2 = Svm3d.dn;

            EPwm4Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncA1*pwm.PeriodMax);
            EPwm6Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncA2*pwm.PeriodMax);
            EPwm5Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncB1*pwm.PeriodMax);
            EPwm8Regs.CMPA.bit.CMPA = (Uint16)(pwm.MfuncB2*pwm.PeriodMax);

        #endif

    }
    else
    {
        EPwm4Regs.DBCTL.bit.OUT_MODE = 0; // Tắt chức năng Dead Band đầu ra (Dead Band output mode).
        EPwm6Regs.DBCTL.bit.OUT_MODE = 0; // Tắt chức năng Dead Band đầu ra (Dead Band output mode).
        EPwm5Regs.DBCTL.bit.OUT_MODE = 0; // Tắt chức năng Dead Band đầu ra (Dead Band output mode).
        EPwm8Regs.DBCTL.bit.OUT_MODE = 0; // Tắt chức năng Dead Band đầu ra (Dead Band output mode).

        EPwm4Regs.AQCTLA.bit.CAU = AQ_CLEAR;
        EPwm4Regs.AQCTLA.bit.CAD = AQ_SET;

        EPwm6Regs.AQCTLA.bit.CAU = AQ_CLEAR;
        EPwm6Regs.AQCTLA.bit.CAD = AQ_SET;

        EPwm5Regs.AQCTLA.bit.CAU = AQ_CLEAR;
        EPwm5Regs.AQCTLA.bit.CAD = AQ_SET;

        EPwm8Regs.AQCTLA.bit.CAU = AQ_CLEAR;
        EPwm8Regs.AQCTLA.bit.CAD = AQ_SET;

        EPwm4Regs.CMPA.bit.CMPA = 0;
        EPwm4Regs.CMPB.bit.CMPB = 0;

        EPwm6Regs.CMPA.bit.CMPA = 0;
        EPwm6Regs.CMPB.bit.CMPB = 0;

        EPwm5Regs.CMPA.bit.CMPA = 0;
        EPwm5Regs.CMPB.bit.CMPB = 0;

        EPwm8Regs.CMPA.bit.CMPA = 0;
        EPwm8Regs.CMPB.bit.CMPB = 0;

        // RESET cac bien trong thuat toan
        rg_har_1st.Angle = 0;
        rg_har_1st.Out = 0;

        rc_Ref.SetpointValue = 0;

        pi_volt_Usd.OUT_I = 0; pi_volt_Usd.OUT = 0;
        pi_volt_Usq.OUT_I = 0; pi_volt_Usq.OUT = 0;

        pi_curr_id.OUT_I = 0; pi_curr_id.OUT = 0;
        pi_curr_iq.OUT_I = 0; pi_curr_iq.OUT = 0;
        pi_curr_iz.OUT_I = 0; pi_curr_iz.OUT = 0;
    }

#endif
#if(SET_MODE_RUN == SINGLE_PHASE_MODE)

    #if (BUILDLEVEL == LEVEL2 || BUILDLEVEL == LEVEL5 || BUILDLEVEL == LEVEL6)
    if(CpuToCLA.EnableFlag == 1)
    {
        START_CONTROLLER = 1;
    }
    else START_CONTROLLER = 0;
   #endif

    if(CpuToCLA.EnableADC == 1 && START_ADC == 2)
       {
           START_ADC = 1;
       }
       if(START_ADC == 1)
       {

           #if(TUNNING_ADC == 1)
               // VaG
               if(CpuToCLA.ADCoffset_VaG > 2048.0)
               {
                   AdcValue.Va_G = CpuToCLA.ADCgain_VaG*(VaG_HCPL - CpuToCLA.ADCoffset_VaG)/(4096.0 - CpuToCLA.ADCoffset_VaG);
               }
               else
               {
                   AdcValue.Va_G = CpuToCLA.ADCgain_VaG*(VaG_HCPL - CpuToCLA.ADCoffset_VaG)/(CpuToCLA.ADCoffset_VaG);
               }
                //VbG
               if(CpuToCLA.ADCoffset_VbG > 2048.0)
               {
               AdcValue.Vb_G = CpuToCLA.ADCgain_VbG*(VbG_HCPL - CpuToCLA.ADCoffset_VbG)/(4096.0 - CpuToCLA.ADCoffset_VbG);
               }
               else
               {
               AdcValue.Vb_G = CpuToCLA.ADCgain_VbG*(VbG_HCPL - CpuToCLA.ADCoffset_VbG)/(CpuToCLA.ADCoffset_VbG);
               }
                          // VcG
               if(CpuToCLA.ADCoffset_VcG > 2048.0)
               {
               AdcValue.Vc_G = CpuToCLA.ADCgain_VcG*(VcG_HCPL - CpuToCLA.ADCoffset_VcG)/(4096.0 - CpuToCLA.ADCoffset_VcG);
               }
               else
               {
               AdcValue.Vc_G = CpuToCLA.ADCgain_VcG*(VcG_HCPL - CpuToCLA.ADCoffset_VcG)/(CpuToCLA.ADCoffset_VcG);
               }
               // data_Vg
               data1.Vg_max_data_cal =  (data1.Vg_rms/400.0) * can2 * 10000 + 10000;
               data1.Vg_min_data_cal = 10000 - (data1.Vg_rms/400.0) * can2 * 10000;
               data1.Vg_max_sub_min_cal = data1.Vg_max_data_cal - data1.Vg_min_data_cal;
               data1.Vg_max_sub_min_real = data1.Vg_max_data_real - data1.Vg_min_data_real;

               // Ia_inv
               if(CpuToCLA.ADCoffset_Ia_inv > 2048.0)
               {
                   AdcValue.Ia_inv = CpuToCLA.ADCgain_Ia_inv*(IA_INV_LEM - CpuToCLA.ADCoffset_Ia_inv)/(4096.0 - CpuToCLA.ADCoffset_Ia_inv);
               }
               else
               {
                   AdcValue.Ia_inv = CpuToCLA.ADCgain_Ia_inv*(IA_INV_LEM - CpuToCLA.ADCoffset_Ia_inv)/(CpuToCLA.ADCoffset_Ia_inv);
               }
               // Ib_inv
               if(CpuToCLA.ADCoffset_Ib_inv > 2048.0)
               {
                   AdcValue.Ib_inv = CpuToCLA.ADCgain_Ib_inv*(IB_INV_LEM  - CpuToCLA.ADCoffset_Ib_inv)/(4096.0 - CpuToCLA.ADCoffset_Ib_inv);
               }
               else
               {
                   AdcValue.Ib_inv = CpuToCLA.ADCgain_Ib_inv*(IB_INV_LEM  - CpuToCLA.ADCoffset_Ib_inv)/(CpuToCLA.ADCoffset_Ib_inv);
               }
               // Ic_inv
               if(CpuToCLA.ADCoffset_Ic_inv > 2048.0)
               {
                   AdcValue.Ic_inv = CpuToCLA.ADCgain_Ic_inv*(IC_INV_LEM - CpuToCLA.ADCoffset_Ic_inv)/(4096.0 - CpuToCLA.ADCoffset_Ic_inv);
               }
               else
               {
                   AdcValue.Ic_inv = CpuToCLA.ADCgain_Ic_inv*(IC_INV_LEM - CpuToCLA.ADCoffset_Ic_inv)/(CpuToCLA.ADCoffset_Ic_inv);
               }
               // data_Ig
               data1.Ig_max_data_cal =  (data1.Ig_rms/10.0) * can2 * 10000 + 10000;
               data1.Ig_min_data_cal = 10000 - (data1.Ig_rms/10.0) * can2 * 10000;
               data1.Ig_max_sub_min_cal = data1.Ig_max_data_cal - data1.Ig_min_data_cal;
               data1.Ig_max_sub_min_real = data1.Ig_max_data_real - data1.Ig_min_data_real;
               // Udc
               if(UDC_HCPL > CpuToCLA.ADCoffset_Udc)
               {
                   AdcValue.Udc = CpuToCLA.ADCgain_Udc*(UDC_HCPL - CpuToCLA.ADCoffset_Udc)/(4096.0 - CpuToCLA.ADCoffset_Udc);
               }
               else AdcValue.Udc = 0.0;
            #endif
               filter_Udc.Vin = AdcValue.Udc;
               LOWPASSFILTER_MACRO(filter_Udc)
               adc_filter.Udc = filter_Udc.Vout;

               filter_VaG.Vin = AdcValue.Va_G;
               LOWPASSFILTER_MACRO(filter_VaG);
               adc_filter.Va_G = filter_VaG.Vout;

               filter_VbG.Vin = AdcValue.Vb_G;
               LOWPASSFILTER_MACRO(filter_VbG);
               adc_filter.Vb_G = filter_VbG.Vout;

               filter_VcG.Vin = AdcValue.Vc_G;
               LOWPASSFILTER_MACRO(filter_VcG);
               adc_filter.Vc_G = filter_VcG.Vout;

               #if(SET_MODE_READ == READ_VOLTAGE_AC_AFTER_LPF)
                   ClaToCPU.ADC_CPU.datalog1  = adc_filter.Va_G;
                   ClaToCPU.ADC_CPU.datalog2  = adc_filter.Vb_G;
                   ClaToCPU.ADC_CPU.datalog3  = adc_filter.Vc_G;
               #endif

               #if(SET_MODE_READ == READ_VOLTAGE_AC_BEFORE_LPF)
                   ClaToCPU.ADC_CPU.datalog1  = AdcValue.Va_G;
                   ClaToCPU.ADC_CPU.datalog2  = AdcValue.Vb_G;
                   ClaToCPU.ADC_CPU.datalog3  = AdcValue.Vc_G;
               #endif

               #if(SET_MODE_READ == READ_VOLTAGE_DC)
                   ClaToCPU.ADC_CPU.datalog1  = adc_filter.Udc;
                   ClaToCPU.ADC_CPU.datalog2  = adc_filter.Vb_G;
                   ClaToCPU.ADC_CPU.datalog3  = adc_filter.Vc_G;
               #endif

               #if(SET_MODE_READ == READ_CURRENT)
                   ClaToCPU.ADC_CPU.datalog1  = AdcValue.Ia_inv;
                   ClaToCPU.ADC_CPU.datalog2  = AdcValue.Ib_inv;
                   ClaToCPU.ADC_CPU.datalog3  = AdcValue.Ic_inv;
               #endif
       }

    if(START_CONTROLLER == 1)
    {
            EPwm4Regs.DBCTL.bit.OUT_MODE = 3; // Dead-band áp dụng cho cả hai tín hiệu PWM A và B.
            EPwm6Regs.DBCTL.bit.OUT_MODE = 3;
            EPwm5Regs.DBCTL.bit.OUT_MODE = 3;
            EPwm8Regs.DBCTL.bit.OUT_MODE = 3;
#if (BUILDLEVEL == LEVEL2)
    IsrTicker++;

           //----------------------------------------------------------------------------
           // Ramp f by rc1
           rc1.TargetValue = 50.00/100.0;
           RC_CLA_MACRO(rc1)

           // Ramp f by rg1
           rg1.Freq = 50.00/100.0;
           RAMP_GEN_CLA_MACRO(rg1)

           // Ramp Us
           rc_Ref.TargetValue = 240.0/400.0;
           RC_CLA_MACRO(rc_Ref)
           Us = (can2)*rc_Ref.SetpointValue*CLAsinPU(rg1.Out);

           // ------------------------------------------------------------------------------
           //  SinPWM - Unipolar
           // ------------------------------------------------------------------------------
   //        Spwm.Usa   = Us;
   //        Spwm.Udc   = CpuToCLA.UdcTesting;
   ////        Spwm.Udc = adc_filter.Udc;
   //        SPWM_1PHASE_CLA_MARCO(Spwm)

           // ------------------------------------------------------------------------------
           //  SinPWM - Bipolar
           // ------------------------------------------------------------------------------
           Spwm.Usa   = Us;
           Spwm.Usb   = Us;
           Spwm.Usc   = Us;
           Spwm.Usd   = Us;
           Spwm.Udc   = 400.0/800.0;
   //        Spwm.Udc = adc_filter.Udc;
           SPWM_1PHASE_BIPOLAR_INTERLEAVED_V3_CLA_MARCO(Spwm)

           pwm.MfuncA1 = Spwm.T1a;
           pwm.MfuncA2 = Spwm.T1b;
         //  pwm.MfuncA1 = 0;
         //  pwm.MfuncA2 = 0;
           pwm.MfuncB1 = Spwm.T1c;
           pwm.MfuncB2 = Spwm.T1d;



           PWM_1P_MACRO(pwm);
           // ------------------------------------------------------------------------------
           //  CLA to CPU
           // ------------------------------------------------------------------------------
           ClaToCPU.ADC_CPU.mUs = Us*Us_max;
           ClaToCPU.MEASUARE_CPU.Theta_gen = rg1.Out;

           // ------------------------------------------------------------------------------
           //  Connect inputs of the PWMDAC module
           // ------------------------------------------------------------------------------
        //   PWMDAC_MACRO((Us + 1.0)/2.0,(adc_filter.Vg + 1.0)/2.0,(Us+1.0)/2.0,1,125)
          // PWMDAC_MACRO(Spwm.T1a,Spwm.T1b,Spwm.T1c,((float)(Us/CpuToCLA.UdcTesting)/2.0 + 1.0)/2.0,125)
#endif
#if (BUILDLEVEL == LEVEL5)

        IsrTicker++;

        // ------------------------------------------------------------------------------
        // Ramp reference current
        //----------------------------------------------------------------------------
        rg1.Freq = 50.00/100.0;
        RAMP_GEN_CLA_MACRO(rg1)

        // Ramp Us
        rc_Ref.TargetValue = 0.5/Is_max;
        RC_CLA_MACRO(rc_Ref)
        ClaToCPU.MEASUARE_CPU.Is = (can2)*rc_Ref.SetpointValue*CLAsinPU(rg1.Out);

        //----------------------------------------------------------------------------
        // PR current controller
        // ---------------------------------------------------------------------------
        //PR_Parameter_curr.Kp = Kp_curr_test;
        //PR_Parameter_curr.Ki = Ki_curr_test;
        PR_Calculator_curr_H1.Errork = ClaToCPU.MEASUARE_CPU.Is - AdcValue.Ia_inv;
        PR_Calcalator_MACRO_new(PR_Calculator_curr_H1,PR_Parameter_curr_H1)


        PR_Calculator_curr_H2.Errork = ClaToCPU.MEASUARE_CPU.Is - AdcValue.Ic_inv;
        PR_Calcalator_MACRO_new(PR_Calculator_curr_H2,PR_Parameter_curr_H2)

        PR_Calculator_curr_extra.Errork = ClaToCPU.MEASUARE_CPU.Is + AdcValue.Ib_inv;
        PR_Calcalator_MACRO_new(PR_Calculator_curr_extra,PR_Parameter_curr_extra)
        //-----------------------------------

        //-----------------------------------------
        // PI current controller H1
        // ---------------------------------------------------------------------------
//        PI_Curr_H1.REF = Is;
//        PI_Curr_H1.INPUT = AdcValue.IL1;
//        PI_Curr_H1.ERROR = PI_Curr_H1.REF - PI_Curr_H1.INPUT;
//        PI_NORMAL_MACRO(PI_Curr_H1)

        //----------------------------------------------------------------------------
        // PI current controller H2
        // ---------------------------------------------------------------------------
//        PI_Curr_H2.REF = Is;
//        PI_Curr_H2.INPUT = AdcValue.IL2;
//        PI_Curr_H2.ERROR = PI_Curr_H2.REF - PI_Curr_H2.INPUT;
//        PI_NORMAL_MACRO(PI_Curr_H2)

        // ------------------------------------------------------------------------------
        //  SinPWM - Unipolar
        // ------------------------------------------------------------------------------
//        Spwm.Usa = PI_Curr.OUT - adc_filter.Vg;
//        Spwm.Udc = CpuToCLA.UdcTesting;
////        Spwm.Udc = adc_filter.Udc;
//        SPWM_1PHASE_CLA_MARCO(Spwm)
        // ------------------------------------------------------------------------------
        //  SinPWM - Bipolar
        // ------------------------------------------------------------------------------
      //  PR_Calculator_curr_extra.OUT = 0;
        Spwm.Usa   = PR_Calculator_curr_H1.OUT;
        Spwm.Usb   = PR_Calculator_curr_H1.OUT + PR_Calculator_curr_extra.OUT;
        //Spwm.Usb   = PR_Calculator_curr_extra.OUT;
        Spwm.Usc   = PR_Calculator_curr_H2.OUT;
        Spwm.Usd   = PR_Calculator_curr_H2.OUT;
        Spwm.Udc   = adc_filter.Udc;
        SPWM_1PHASE_BIPOLAR_INTERLEAVED_V3_CLA_MARCO(Spwm)

        pwm.MfuncA1 = Spwm.T1a;
        pwm.MfuncA2 = Spwm.T1b;
        pwm.MfuncB1 = Spwm.T1c;
        pwm.MfuncB2 = Spwm.T1d;

        PWM_1P_MACRO(pwm);


        // ------------------------------------------------------------------------------
        //  CLA to CPU
        // ------------------------------------------------------------------------------
        ClaToCPU.ADC_CPU.mUs = Spwm.Usc*Us_max;
        ClaToCPU.ADC_CPU.Ic_inv = AdcValue.Ic_inv;

        // ------------------------------------------------------------------------------
        //  Connect inputs of the PWMDAC module
        // ------------------------------------------------------------------------------
     //   PWMDAC_MACRO((AdcValue.IL1+1.0)/2.0,(AdcValue.IL2+1.0)/2.0,(AdcValue.IL3+1.0)/2.0,(AdcValue.IL4+1.0)/2.0,125)

        // ------------------------------------------------------------------------------
        //  Error
        // ------------------------------------------------------------------------------
      //  if (PI_Curr_H1.OUT > 0.990 || PI_Curr_H1.OUT < -0.990 || PI_Curr_H2.OUT > 0.990 || PI_Curr_H2.OUT < -0.990  )
        //    controller_error_curr++;
      //  else controller_error_curr = 0;

       // if(controller_error_curr > 100) ClaToCPU.MEASUARE_CPU.flag = 1;


    #endif
#if (BUILDLEVEL == LEVEL6)

        IsrTicker++;

        // ramp freq
               rg1.Freq = 50.00/100.0;
               RAMP_GEN_CLA_MACRO(rg1)
               // ramp us
               rc_Ref.TargetValue = 10.0/Us_max;
               RC_CLA_MACRO(rc_Ref)
               ClaToCPU.MEASUARE_CPU.Us = (can2)*rc_Ref.SetpointValue*CLAsinPU(rg1.Out);
               // Voltage loop
        PR_Calculator_voltage.Errork = ClaToCPU.MEASUARE_CPU.Us - AdcValue.Va_G;
        PR_Calcalator_MACRO_new(PR_Calculator_voltage,PR_Parameter_voltage)
        ClaToCPU.MEASUARE_CPU.Is = PR_Calculator_voltage.OUT/2;
        //----------------------------------------------------------------------------
        // PR current controller
        PR_Calculator_curr_H1.Errork = ClaToCPU.MEASUARE_CPU.Is - AdcValue.Ia_inv;
        PR_Calcalator_MACRO_new(PR_Calculator_curr_H1,PR_Parameter_curr_H1)


        PR_Calculator_curr_H2.Errork = ClaToCPU.MEASUARE_CPU.Is - AdcValue.Ic_inv;
        PR_Calcalator_MACRO_new(PR_Calculator_curr_H2,PR_Parameter_curr_H2)

        PR_Calculator_curr_extra.Errork = ClaToCPU.MEASUARE_CPU.Is + AdcValue.Ib_inv;
        PR_Calcalator_MACRO_new(PR_Calculator_curr_extra,PR_Parameter_curr_extra)

        // ------------------------------------------------------------------------------
        //  SinPWM - Bipolar
        // ------------------------------------------------------------------------------
       // PR_Calculator_curr_extra.OUT = 0;
        Spwm.Usa   = PR_Calculator_curr_H1.OUT;
        Spwm.Usb   = PR_Calculator_curr_H1.OUT + PR_Calculator_curr_extra.OUT;
        //Spwm.Usb   = PR_Calculator_curr_extra.OUT;
        Spwm.Usc   = PR_Calculator_curr_H2.OUT;
        Spwm.Usd   = PR_Calculator_curr_H2.OUT;
        Spwm.Udc   = adc_filter.Udc;
        SPWM_1PHASE_BIPOLAR_INTERLEAVED_V3_CLA_MARCO(Spwm)

        // ------------------------------------------------------------------------------
        //  Connect inputs of the PWM_DRV module and call the PWM signal generation macro
        // ------------------------------------------------------------------------------
        pwm.MfuncA1 = Spwm.T1a;
        pwm.MfuncA2 = Spwm.T1b;
        pwm.MfuncB1 = Spwm.T1c;
        pwm.MfuncB2 = Spwm.T1d;
        PWM_1P_MACRO(pwm);

        // ------------------------------------------------------------------------------

 #endif
    }
    else
    {
           EPwm4Regs.DBCTL.bit.OUT_MODE = 0; // Tắt chức năng Dead Band đầu ra (Dead Band output mode).
           EPwm6Regs.DBCTL.bit.OUT_MODE = 0; // Tắt chức năng Dead Band đầu ra (Dead Band output mode).
           EPwm5Regs.DBCTL.bit.OUT_MODE = 0; // Tắt chức năng Dead Band đầu ra (Dead Band output mode).
           EPwm8Regs.DBCTL.bit.OUT_MODE = 0; // Tắt chức năng Dead Band đầu ra (Dead Band output mode).

           EPwm4Regs.AQCTLA.bit.CAU = AQ_CLEAR;
           EPwm4Regs.AQCTLA.bit.CAD = AQ_SET;

           EPwm6Regs.AQCTLA.bit.CAU = AQ_CLEAR;
           EPwm6Regs.AQCTLA.bit.CAD = AQ_SET;

           EPwm5Regs.AQCTLA.bit.CAU = AQ_CLEAR;
           EPwm5Regs.AQCTLA.bit.CAD = AQ_SET;

           EPwm8Regs.AQCTLA.bit.CAU = AQ_CLEAR;
           EPwm8Regs.AQCTLA.bit.CAD = AQ_SET;

           EPwm4Regs.CMPA.bit.CMPA = 0;
           EPwm4Regs.CMPB.bit.CMPB = 0;

           EPwm6Regs.CMPA.bit.CMPA = 0;
           EPwm6Regs.CMPB.bit.CMPB = 0;

           EPwm5Regs.CMPA.bit.CMPA = 0;
           EPwm5Regs.CMPB.bit.CMPB = 0;

           EPwm8Regs.CMPA.bit.CMPA = 0;
           EPwm8Regs.CMPB.bit.CMPB = 0;


       }


 #endif


}

//
// Task 2
//
__interrupt void Cla1Task2 ( void )
{
    #if (CLA_DEBUG==1)
    __mdebugstop();
    #endif
    TaskCpu1Cla1_task2++;

}

//
// Task 3
//
__interrupt void Cla1Task3 ( void )
{
    #if (CLA_DEBUG==1)
    __mdebugstop();
    #endif
}

//
// Task 4
//
__interrupt void Cla1Task4 ( void )
{
    #if (CLA_DEBUG==1)
    __mdebugstop();
    #endif
}

//
// Task 5
//
__interrupt void Cla1Task5 ( void )
{
    #if (CLA_DEBUG==1)
    __mdebugstop();
    #endif
}

//
// Task 6
//
__interrupt void Cla1Task6 ( void )
{
    #if (CLA_DEBUG==1)
    __mdebugstop();
    #endif
}

//
// Task 7
//
__interrupt void Cla1Task7 ( void )
{
    #if (CLA_DEBUG==1)
    __mdebugstop();
    #endif
}

//
// Task 8
//
__interrupt void Cla1Task8 ( void )
{
    TaskCpu1Cla1 = 0;
    TaskCpu1Cla1_task2 = 0;

#if(SET_MODE_RUN == THREE_PHASE_MODE)

    //KALMAN_INIT(kf_VaG, 0.01f, 1.0f, 0.5f);  // Khởi tạo Kalman

//    KALMAN_INIT(kf_VaG, 0.1f, 0.5f, 0.5f); // Tăng Q, giảm R để bộ lọc phản ứng nhanh hơn.
//    KALMAN_INIT(kf_VbG, 0.1f, 0.5f, 0.5f); // Tăng Q, giảm R để bộ lọc phản ứng nhanh hơn.
//    KALMAN_INIT(kf_VcG, 0.1f, 0.5f, 0.5f); // Tăng Q, giảm R để bộ lọc phản ứng nhanh hơn.

    CLARKE_3PHASE_CLA_INIT(clarke_curr)
    clarke_volt  = clarke_curr;

    PARK_CLA_INIT(park_curr)
    park_volt = park_curr;
    park_volt_pll = park_curr;
    iPARK_CLA_INIT(ipark_voltref)

    SVM3D_DQZ_GEN_CLA_INT_1(Svm3d)

    pwm.PeriodMax = 1000;

    #if(BUILDLEVEL == LEVEL1)

        RAMP_GEN_CLA_INIT(rg_har_1st)
        rg_har_1st.StepAngleMax = 150.0*0.00002;

        RC_INT_MACRO(rc_Ref)
        rc_Ref.StepRampDec = 0.0005/10/400.0;
        rc_Ref.StepRampInc = 0.0005/10/400.0;

    #endif

    #if(BUILDLEVEL == LEVEL3)

        RAMP_GEN_CLA_INIT(rg_har_1st)
        rg_har_1st.StepAngleMax = 150.0*0.00002;

        RC_INT_MACRO(rc_Ref)
        rc_Ref.StepRampDec = 0.00001/10.0;
        rc_Ref.StepRampInc = 0.00001/10.0;

    #endif

    #if(BUILDLEVEL == LEVEL4)

        RAMP_GEN_CLA_INIT(rg_har_1st)
        rg_har_1st.StepAngleMax = 150.0*0.00002;

        RC_INT_MACRO(rc_Ref)

        #if(VAC_REF == 10 || VAC_REF == 25 || VAC_REF == 35 || VAC_REF == 50 || VAC_REF == 75)
            rc_Ref.StepRampDec = (0.0005/2)/400.0;
            rc_Ref.StepRampInc = (0.0005/2)/400.0;

        #elif(VAC_REF == 100) // Chia 1 để lấy kết quả ramp không quá lớn, lấy được kết quả
            rc_Ref.StepRampDec = (0.0005/2)/400.0;
            rc_Ref.StepRampInc = (0.0005/2)/400.0;

        #elif(VAC_REF == 120)
            rc_Ref.StepRampDec = (0.0005/2)/400.0;
            rc_Ref.StepRampInc = (0.0005/2)/400.0;

        #else // Trường hợp VAC_REF không rơi vào những cái đặt thì vẫn có giá trị
            rc_Ref.StepRampDec = (0.0005/5)/400.0;
            rc_Ref.StepRampInc = (0.0005/5)/400.0;
        #endif
#endif

    #if(BUILDLEVEL == LEVEL7)
        rc_Ref.StepRampDec = 0.00005/Is_max;
        rc_Ref.StepRampInc = 0.00005/Is_max;
    #endif

    #if(BUILDLEVEL == LEVEL3)

        // Current controller
        PI_NORMAL_INT(pi_curr_id)
        pi_curr_id.Ts = (float)Ti;
        pi_curr_id.Kp = KP_CURR_LOOP;
        pi_curr_id.Ki = KI_CURR_LOOP;
        pi_curr_id.IN_max   = 10.0;
        pi_curr_id.OUT_max  = 400.0;

        PI_NORMAL_INT(pi_curr_iq)
        pi_curr_iq.Ts = (float)Ti;
        pi_curr_iq.Kp = KP_CURR_LOOP;
        pi_curr_iq.Ki = KI_CURR_LOOP;
        pi_curr_iq.IN_max   = 10.0;
        pi_curr_iq.OUT_max  = 400.0;

        PI_NORMAL_INT(pi_curr_iz)
        pi_curr_iz.Ts = (float)Ti;
        pi_curr_iz.Kp = KP_CURR_LOOP_Z;
        pi_curr_iz.Ki = KI_CURR_LOOP_Z;
        pi_curr_iz.IN_max   = 10.0;
        pi_curr_iz.OUT_max  = 400.0;

    #endif

    #if(BUILDLEVEL == LEVEL4)

        loop_volt_Us = 0;

        // Current controller
        PI_NORMAL_INT(pi_curr_id)
        pi_curr_id.Ts = (float)Ti;
        pi_curr_id.Kp = KP_CURR_LOOP_1;
        pi_curr_id.Ki = KI_CURR_LOOP_1;
        pi_curr_id.IN_max   = 10.0;
        pi_curr_id.OUT_max  = 400.0;

        PI_NORMAL_INT(pi_curr_iq)
        pi_curr_iq.Ts = (float)Ti;
        pi_curr_iq.Kp = KP_CURR_LOOP_1;
        pi_curr_iq.Ki = KI_CURR_LOOP_1;
        pi_curr_iq.IN_max   = 10.0;
        pi_curr_iq.OUT_max  = 400.0;

        PI_NORMAL_INT(pi_curr_iz)
        pi_curr_iz.Ts = (float)Ti;
        pi_curr_iz.Kp = KP_CURR_LOOP_1;
        pi_curr_iz.Ki = KI_CURR_LOOP_1;
        pi_curr_iz.IN_max   = 10.0;
        pi_curr_iz.OUT_max  = 400.0;

        // Voltage controller
        PI_NORMAL_INT(pi_volt_Usd)
        pi_volt_Usd.Ts = (float)T_Us;
        pi_volt_Usd.Kp = KP_VOLT_US_LOOP;
        pi_volt_Usd.Ki = KI_VOLT_US_LOOP;
        pi_volt_Usd.IN_max   = 400.0;
        pi_volt_Usd.OUT_max  = 10.0;

        PI_NORMAL_INT(pi_volt_Usq)
        pi_volt_Usq.Ts = (float)T_Us;
        pi_volt_Usq.Kp = KP_VOLT_US_LOOP;
        pi_volt_Usq.Ki = KI_VOLT_US_LOOP;
        pi_volt_Usq.IN_max   = 400.0;
        pi_volt_Usq.OUT_max  = 10.0;

    #endif

    #if(BUILDLEVEL == LEVEL7)

        // Current controller
        PI_NORMAL_INT(pi_curr_id)
        pi_curr_id.Ts = (float)Ti;
        pi_curr_id.Kp = KP_CURR_LOOP;
        pi_curr_id.Ki = KI_CURR_LOOP;
        pi_curr_id.IN_max   = (float)Is_max;
        pi_curr_id.OUT_max  = (float)Us_max;

        PI_NORMAL_INT(pi_curr_iq)
        pi_curr_iq.Ts = (float)Ti;
        pi_curr_iq.Kp = KP_CURR_LOOP;
        pi_curr_iq.Ki = KI_CURR_LOOP;
        pi_curr_iq.IN_max   = (float)Is_max;
        pi_curr_iq.OUT_max  = (float)Us_max;

        PI_NORMAL_INT(pi_curr_iz)
        pi_curr_iz.Ts = (float)Ti;
        pi_curr_iz.Kp = KP_CURR_LOOP_Z;
        pi_curr_iz.Ki = KI_CURR_LOOP_Z;
        pi_curr_iz.IN_max   = (float)Is_max;
        pi_curr_iz.OUT_max  = (float)Us_max;
    #endif

    // Filter ADC
    filter_Udc.Heso_out = 0.96;
    filter_Udc.Heso_in = 0.04;
    filter_Udc.Vin = 0;
    filter_Udc.Vout_k1 = 0;
    filter_Udc.Vout = 0;

    filter_VaG.Heso_out = 0.1373;
    filter_VaG.Heso_in = 0.8627;
    filter_VaG.Vin = 0;
    filter_VaG.Vout_k1 = 0;
    filter_VaG.Vout = 0;

    filter_VbG.Heso_out = 0.1373;
    filter_VbG.Heso_in = 0.8627;
    filter_VbG.Vin = 0;
    filter_VbG.Vout_k1 = 0;
    filter_VbG.Vout = 0;

    filter_VcG.Heso_out = 0.1373;
    filter_VcG.Heso_in = 0.8627;
    filter_VcG.Vin = 0;
    filter_VcG.Vout_k1 = 0;
    filter_VcG.Vout = 0;

/*
    filter_VaG.Heso_out = 1.0/(1.0 + 0.0001*2*PI*10000);
    filter_VaG.Heso_in = 1.0 - filter_VaG.Heso_out;
    Heso_in = deltaT/(RC +deltaT)
    Heso_out = RC/(RC + deltaT)
    fc = 1/(2*pi*RC)
    RC = 1/(2*pi*fc) = 1.0
    fc = 0.16kHz = 160Hz
*/

    IsrTicker = 0;
    START_ADC = 2;

    data1.Vg_rms = DATA1_VG_RMS;
    data1.Ig_rms   = DATA1_IG_RMS;

#endif

#if(SET_MODE_RUN == SINGLE_PHASE_MODE)
    // Control mode GC by default
     //  ControlMode = 1;

       //-------------------------------------------------------------
    // Filter ADC
       filter_Udc.Heso_out = 0.96;
       filter_Udc.Heso_in = 0.04;
       filter_Udc.Vin = 0;
       filter_Udc.Vout_k1 = 0;
       filter_Udc.Vout = 0;

       filter_VaG.Heso_out = 0.1373;
       filter_VaG.Heso_in = 0.8627;
       filter_VaG.Vin = 0;
       filter_VaG.Vout_k1 = 0;
       filter_VaG.Vout = 0;

       filter_VbG.Heso_out = 0.1373;
       filter_VbG.Heso_in = 0.8627;
       filter_VbG.Vin = 0;
       filter_VbG.Vout_k1 = 0;
       filter_VbG.Vout = 0;

       filter_VcG.Heso_out = 0.1373;
       filter_VcG.Heso_in = 0.8627;
       filter_VcG.Vin = 0;
       filter_VcG.Vout_k1 = 0;
       filter_VcG.Vout = 0;
    //  i = 0 ;

       RAMP_GEN_CLA_INIT(rg1)
       rg1.StepAngleMax = 100*0.00002;

       pwm.PeriodMax = 1000; /* Initializa ePWM */

       SPWM_CLA_INT(Spwm)

       //================================================================
       // PARK 1 PHASE
       PARK_1PHASE_CLA_INT(park_volt_Vg)
       park_volt_Vg.Ts = 0.00002;
       park_volt_Vg.wn = 100*3.14159265358979;
       PARK_1PHASE_CLA_PARA(park_volt_Vg)

       //================================================================
       // PLL GRID VOLTAGE
       PLL_1PHASE_CLA_INT(pll_Vg)
       pll_Vg.Kp = 4;
       pll_Vg.Ki = 30;
       pll_Vg.Ts = 0.00002;
       pll_Vg.IN_MAX = 400;
       pll_Vg.OUT_MAX = 200.0*3.14159265358979;
       pll_Vg.wref    = 0.5;

       //================================================================

       RC_INT_MACRO(rc1)
       rc1.StepRampDec = 0.01/100;
       rc1.StepRampInc = 0.01/100;

       RC_INT_MACRO(rc_Ref)

   #if(BUILDLEVEL == LEVEL2)
       // Open loop
       rc_Ref.StepRampDec = 0.0005/Us_max;
       rc_Ref.StepRampInc = 0.0005/Us_max;
   #endif
   #if(BUILDLEVEL == LEVEL5)
    // Current loop grid mode
    rc_Ref.StepRampDec = 0.001/Is_max;
    rc_Ref.StepRampInc = 0.001/Is_max;
   #endif
   #if(BUILDLEVEL == LEVEL5)
    // Kp & Ki are defined in PV Setting
    PR_CACULATOR_INT_new(PR_Calculator_curr_H1)
    PR_PARAMETER_INT_new(PR_Parameter_curr_H1)
    PR_Parameter_curr_H1.IN_MAX = Is_max;
    PR_Parameter_curr_H1.OUT_MAX = Us_max;
    PR_Parameter_curr_H1.Kp = KP_CURR_LOOP_PR;
    PR_Parameter_curr_H1.Ki = KI_CURR_LOOP_PR;
    PR_Parameter_curr_H1.Ts = Ti;
    PR_Parameter_curr_H1.w1 = 314.0;
    PR_CALCULATOR_PARAMETER_fw1(PR_Parameter_curr_H1)
    //PR_CALCULATOR_PARAMETER_V1(PR_Parameter_curr,1)

    PR_CACULATOR_INT_new(PR_Calculator_curr_H2)
    PR_PARAMETER_INT_new(PR_Parameter_curr_H2)
    PR_Parameter_curr_H2.IN_MAX = Is_max;
    PR_Parameter_curr_H2.OUT_MAX = Us_max;
    PR_Parameter_curr_H2.Kp = KP_CURR_LOOP_PR;
    PR_Parameter_curr_H2.Ki = KI_CURR_LOOP_PR;
    //PR_Parameter_curr_H2.Kp = 2.5;
    //PR_Parameter_curr_H2.Ki = 1000;
    PR_Parameter_curr_H2.Ts = Ti;
    PR_Parameter_curr_H2.w1 = 314.0;
    PR_CALCULATOR_PARAMETER_fw1(PR_Parameter_curr_H2)


    PR_CACULATOR_INT_new(PR_Calculator_curr_extra)
    PR_PARAMETER_INT_new(PR_Parameter_curr_extra)
    PR_Parameter_curr_extra.IN_MAX = Is_max;
    PR_Parameter_curr_extra.OUT_MAX = Us_max;
    PR_Parameter_curr_extra.Kp = 5.8;
    PR_Parameter_curr_extra.Ki = 1000;
    PR_Parameter_curr_extra.Ts = Ti;
    PR_Parameter_curr_extra.w1 = 314.0;
    PR_CALCULATOR_PARAMETER_fw1(PR_Parameter_curr_extra);
#endif
#if(BUILDLEVEL == LEVEL6)
 // Kp & Ki are defined in PV Setting
// voltage loop grid mode
rc_Ref.StepRampDec = 0.00005/Us_max;
rc_Ref.StepRampInc = 0.00005/Us_max;

 PR_CACULATOR_INT_new(PR_Calculator_curr_H1)
 PR_PARAMETER_INT_new(PR_Parameter_curr_H1)
 PR_Parameter_curr_H1.IN_MAX = Is_max;
 PR_Parameter_curr_H1.OUT_MAX = Us_max;
 PR_Parameter_curr_H1.Kp = KP_CURR_LOOP_PR;
 PR_Parameter_curr_H1.Ki = KI_CURR_LOOP_PR;
 PR_Parameter_curr_H1.Ts = Ti;
 PR_Parameter_curr_H1.w1 = 314.0;
 PR_CALCULATOR_PARAMETER_fw1(PR_Parameter_curr_H1)
 //PR_CALCULATOR_PARAMETER_V1(PR_Parameter_curr,1)

 PR_CACULATOR_INT_new(PR_Calculator_curr_H2)
 PR_PARAMETER_INT_new(PR_Parameter_curr_H2)
 PR_Parameter_curr_H2.IN_MAX = Is_max;
 PR_Parameter_curr_H2.OUT_MAX = Us_max;
 PR_Parameter_curr_H2.Kp = KP_CURR_LOOP_PR;
 PR_Parameter_curr_H2.Ki = KI_CURR_LOOP_PR;
 //PR_Parameter_curr_H2.Kp = 2.5;
 //PR_Parameter_curr_H2.Ki = 1000;
 PR_Parameter_curr_H2.Ts = Ti;
 PR_Parameter_curr_H2.w1 = 314.0;
 PR_CALCULATOR_PARAMETER_fw1(PR_Parameter_curr_H2)


 PR_CACULATOR_INT_new(PR_Calculator_curr_extra)
 PR_PARAMETER_INT_new(PR_Parameter_curr_extra)
 PR_Parameter_curr_extra.IN_MAX = Is_max;
 PR_Parameter_curr_extra.OUT_MAX = Us_max;
 PR_Parameter_curr_extra.Kp = 5.8;
 PR_Parameter_curr_extra.Ki = 1000;
 PR_Parameter_curr_extra.Ts = Ti;
 PR_Parameter_curr_extra.w1 = 314.0;
 PR_CALCULATOR_PARAMETER_fw1(PR_Parameter_curr_extra);

 PR_CACULATOR_INT_new(PR_Calculator_voltage)
 PR_PARAMETER_INT_new(PR_Parameter_voltage)
 PR_Parameter_voltage.IN_MAX = Us_max;
 PR_Parameter_voltage.OUT_MAX = Is_max;
 PR_Parameter_voltage.Kp = KP_voltage_LOOP_PR;
 PR_Parameter_voltage.Ki = KI_voltage_LOOP_PR;
 PR_Parameter_voltage.Ts = Ti;
 PR_Parameter_voltage.w1 = 314.0;
 PR_CALCULATOR_PARAMETER_fw1(PR_Parameter_voltage);

#endif
       #endif
       START_ADC = 2;

}

//
// End of file
//
